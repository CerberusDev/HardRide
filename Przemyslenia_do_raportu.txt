Niesamowite, ale od 3 lat wystêpuje bug, który niesamowicie utrudnia robotê: Kiedy sfailuje kompilacja shadera, wywo³anie polecenia glGetShaderInfoLog() wypluwa pusty string. Wystêpuje to na niektórych urz¹dzeniach.

http://stackoverflow.com/questions/4588800/glgetshaderinfolog-returns-empty-string-android


Pierwsze problemy z wydajnoœci¹: narysowanie ok 120 kostek (cube, 6 vert, 12 tris). Cieniowanie Phonga: 11-12 FPS, Cieniowanie Gourauda: 11-12 FPS, Brak oœwietlenia: 12-13 FPS. Funkcja, która wo³a draw() na 120 kostkach zajmuje ok. 84ms, co jest jak¹œ tragedi¹.

Wyrzucaj¹c wyznaczanie macierzy Model-Widok i Model-Widok-Projekcja co klatkê zyskujemy ok. 3ms, wiêc w zasadzie du¿o, ale ma³o w porównaniu do pozosta³ych 80ciu.

Po przerobieniu uzyskiwania atrybutów uniformów i atrybutów (zapamiêtane, zamiast wywo³ywania glGetXxxLocation() za ka¿dym razem) jest skok do 15-16 FPSów, draw zajmuje ok. 63ms.

Po przemyœleniu: Dla ka¿dej kostki jest tworzony osobny shader, wiêc w jednej klatce jest bindowanych 120 programów cieniuj¹cych, co mo¿e mieæ taki niszczycielski wp³yw na wydajnoœæ.

Mno¿enie macierzy oraz ustawianie uniformów w ka¿dej klatce: 62ms
Samo ustawianie uniformów w ka¿dej klatce: 60ms
Nie robienie ¿adnej z tych rzeczy w ¿adnej klatce: 50ms

Zmiana, by nie robiæ useProgram 120 razy w klatce - znikomy przyrost, 60ms (zamiast 62ms)

W³¹czanie i wy³¹czanie atrybutów tylko dwa razy w klatce, bo tylko dwa shadery: draw trwa 51ms, wiêc sza³u nie ma, ale jest wyraŸnie lepiej, 20 FPS osi¹gniête.

U¿ywane by³y vertex_array, zamiast VBO - oznacza to, ¿e dane obiektu by³y przechowywane w pamiêci CPU i przesy³ane na GPU w ka¿dej klatce. Po wrzuceniu danych wierzcho³ków (pozycje i normalki jako osobne bufory) na pamiêæ GPU mamy 43ms i 24 FPS.

Tak samo w ka¿dej klatce przesy³ane by³y indeksy do rysowania. Po wrzuceniu ich w IBO i tylko bindowaniu mamy 29ms i 34 FPS

Odrobinê pomaga wrzucenie pozycji i normalek wierzcho³ków nie do dwóch osobnych, a jednego bufora: 28ms i 35-36 FPS

Jeszcze jedna mikrooptymalizacja: Nie wo³amy glBindBuffer z nullowym wskaŸnikiem po ka¿dym poleceniu rysowania (to by³o zabezpieczenie, ¿eby przez przypadek gdzieœ indziej nie u¿yæ tego bufora) - teraz mamy 25ms i 39-40 FPS